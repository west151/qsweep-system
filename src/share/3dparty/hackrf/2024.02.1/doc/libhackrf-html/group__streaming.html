<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libhackrf: Transmit &amp; receive operation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libhackrf
   </div>
   <div id="projectbrief">HackRF SDR platform library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Transmit &amp; receive operation</div></div>
</div><!--header-->
<div class="contents">

<p>RX and TX, callbacks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhackrf__transfer.html">hackrf_transfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB transfer information passed to RX or TX callback.  <a href="structhackrf__transfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae581302423a0d3dd5a2e68139426ba06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gae581302423a0d3dd5a2e68139426ba06">SAMPLES_PER_BLOCK</a>&#160;&#160;&#160;8192</td></tr>
<tr class="memdesc:gae581302423a0d3dd5a2e68139426ba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of samples per tuning when sweeping.  <a href="group__streaming.html#gae581302423a0d3dd5a2e68139426ba06">More...</a><br /></td></tr>
<tr class="separator:gae581302423a0d3dd5a2e68139426ba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c28f2a4b49e991e1fa97892e60e25f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga05c28f2a4b49e991e1fa97892e60e25f">BYTES_PER_BLOCK</a>&#160;&#160;&#160;16384</td></tr>
<tr class="memdesc:ga05c28f2a4b49e991e1fa97892e60e25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes per tuning for sweeping.  <a href="group__streaming.html#ga05c28f2a4b49e991e1fa97892e60e25f">More...</a><br /></td></tr>
<tr class="separator:ga05c28f2a4b49e991e1fa97892e60e25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac885702b61abc57399865ba062a46a52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gac885702b61abc57399865ba062a46a52">MAX_SWEEP_RANGES</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:gac885702b61abc57399865ba062a46a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of sweep ranges to be specified for <a class="el" href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">hackrf_init_sweep</a>.  <a href="group__streaming.html#gac885702b61abc57399865ba062a46a52">More...</a><br /></td></tr>
<tr class="separator:gac885702b61abc57399865ba062a46a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga338cc5b413e5706a3e1eb63bb292a6a3"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a>) (<a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> *transfer)</td></tr>
<tr class="memdesc:ga338cc5b413e5706a3e1eb63bb292a6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample block callback, used in RX and TX (set via <a class="el" href="group__streaming.html#ga5960330666b4bf32aa49beb7780f44fe">hackrf_start_rx</a>, <a class="el" href="group__streaming.html#ga1d531271e2d568364d758e902514a11b">hackrf_start_rx_sweep</a> and <a class="el" href="group__streaming.html#gab06dfb4e0f16868d05d941e4f3bb5d87">hackrf_start_tx</a>).  <a href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">More...</a><br /></td></tr>
<tr class="separator:ga338cc5b413e5706a3e1eb63bb292a6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a8eb91144c6bf1a865b9a55092f33c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga34a8eb91144c6bf1a865b9a55092f33c">hackrf_tx_block_complete_cb_fn</a>) (<a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> *transfer, int)</td></tr>
<tr class="memdesc:ga34a8eb91144c6bf1a865b9a55092f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block complete callback.  <a href="group__streaming.html#ga34a8eb91144c6bf1a865b9a55092f33c">More...</a><br /></td></tr>
<tr class="separator:ga34a8eb91144c6bf1a865b9a55092f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002023cc3bf3d961cd4664bd6f091f7b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga002023cc3bf3d961cd4664bd6f091f7b">hackrf_flush_cb_fn</a>) (void *flush_ctx, int)</td></tr>
<tr class="memdesc:ga002023cc3bf3d961cd4664bd6f091f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush (end of transmission) callback.  <a href="group__streaming.html#ga002023cc3bf3d961cd4664bd6f091f7b">More...</a><br /></td></tr>
<tr class="separator:ga002023cc3bf3d961cd4664bd6f091f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadd13ea4602d90423052eb55dafab007a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gadd13ea4602d90423052eb55dafab007a">sweep_style</a> { <br />
&#160;&#160;<a class="el" href="group__streaming.html#ggadd13ea4602d90423052eb55dafab007aadc101ebf31c49c2d4b80b7c6f59f22cb">LINEAR</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__streaming.html#ggadd13ea4602d90423052eb55dafab007aaf59ecbbe3f314395e0ffa01b0f1f4e56">INTERLEAVED</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:gadd13ea4602d90423052eb55dafab007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sweep mode enum  <a href="group__streaming.html#gadd13ea4602d90423052eb55dafab007a">More...</a><br /></td></tr>
<tr class="separator:gadd13ea4602d90423052eb55dafab007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5960330666b4bf32aa49beb7780f44fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga5960330666b4bf32aa49beb7780f44fe">hackrf_start_rx</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, <a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a> callback, void *rx_ctx)</td></tr>
<tr class="memdesc:ga5960330666b4bf32aa49beb7780f44fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start receiving.  <a href="group__streaming.html#ga5960330666b4bf32aa49beb7780f44fe">More...</a><br /></td></tr>
<tr class="separator:ga5960330666b4bf32aa49beb7780f44fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4725318ea54f83ca13a34ecc377d8072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga4725318ea54f83ca13a34ecc377d8072">hackrf_stop_rx</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device)</td></tr>
<tr class="memdesc:ga4725318ea54f83ca13a34ecc377d8072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop receiving.  <a href="group__streaming.html#ga4725318ea54f83ca13a34ecc377d8072">More...</a><br /></td></tr>
<tr class="separator:ga4725318ea54f83ca13a34ecc377d8072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06dfb4e0f16868d05d941e4f3bb5d87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gab06dfb4e0f16868d05d941e4f3bb5d87">hackrf_start_tx</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, <a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a> callback, void *tx_ctx)</td></tr>
<tr class="memdesc:gab06dfb4e0f16868d05d941e4f3bb5d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start transmitting.  <a href="group__streaming.html#gab06dfb4e0f16868d05d941e4f3bb5d87">More...</a><br /></td></tr>
<tr class="separator:gab06dfb4e0f16868d05d941e4f3bb5d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab905e4d999ee5f35e8911d18ef250d5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gab905e4d999ee5f35e8911d18ef250d5b">hackrf_set_tx_block_complete_callback</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, <a class="el" href="group__streaming.html#ga34a8eb91144c6bf1a865b9a55092f33c">hackrf_tx_block_complete_cb_fn</a> callback)</td></tr>
<tr class="memdesc:gab905e4d999ee5f35e8911d18ef250d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup callback to be called when an USB transfer is completed.  <a href="group__streaming.html#gab905e4d999ee5f35e8911d18ef250d5b">More...</a><br /></td></tr>
<tr class="separator:gab905e4d999ee5f35e8911d18ef250d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677baa64e0aebf3cd38b65633b920cfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga677baa64e0aebf3cd38b65633b920cfe">hackrf_enable_tx_flush</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, <a class="el" href="group__streaming.html#ga002023cc3bf3d961cd4664bd6f091f7b">hackrf_flush_cb_fn</a> callback, void *flush_ctx)</td></tr>
<tr class="memdesc:ga677baa64e0aebf3cd38b65633b920cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup flush (end-of-transmission) callback.  <a href="group__streaming.html#ga677baa64e0aebf3cd38b65633b920cfe">More...</a><br /></td></tr>
<tr class="separator:ga677baa64e0aebf3cd38b65633b920cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a1632c1863cb02cece8d328d809c71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga15a1632c1863cb02cece8d328d809c71">hackrf_stop_tx</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device)</td></tr>
<tr class="memdesc:ga15a1632c1863cb02cece8d328d809c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop transmission.  <a href="group__streaming.html#ga15a1632c1863cb02cece8d328d809c71">More...</a><br /></td></tr>
<tr class="separator:ga15a1632c1863cb02cece8d328d809c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9037db244680c7dd5dac0abe4d2fb4a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga9037db244680c7dd5dac0abe4d2fb4a5">hackrf_set_tx_underrun_limit</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint32_t value)</td></tr>
<tr class="memdesc:ga9037db244680c7dd5dac0abe4d2fb4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set transmit underrun limit.  <a href="group__streaming.html#ga9037db244680c7dd5dac0abe4d2fb4a5">More...</a><br /></td></tr>
<tr class="separator:ga9037db244680c7dd5dac0abe4d2fb4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10eb6ec19afb5b137cc93926c324593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gad10eb6ec19afb5b137cc93926c324593">hackrf_set_rx_overrun_limit</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint32_t value)</td></tr>
<tr class="memdesc:gad10eb6ec19afb5b137cc93926c324593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set receive overrun limit.  <a href="group__streaming.html#gad10eb6ec19afb5b137cc93926c324593">More...</a><br /></td></tr>
<tr class="separator:gad10eb6ec19afb5b137cc93926c324593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8cc13d8d4fd29d0e4e2b7e31f55603b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#gad8cc13d8d4fd29d0e4e2b7e31f55603b">hackrf_is_streaming</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device)</td></tr>
<tr class="memdesc:gad8cc13d8d4fd29d0e4e2b7e31f55603b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query device streaming status.  <a href="group__streaming.html#gad8cc13d8d4fd29d0e4e2b7e31f55603b">More...</a><br /></td></tr>
<tr class="separator:gad8cc13d8d4fd29d0e4e2b7e31f55603b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8915d11aa512c0d369771136d872dd22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga8915d11aa512c0d369771136d872dd22">hackrf_set_hw_sync_mode</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, const uint8_t value)</td></tr>
<tr class="memdesc:ga8915d11aa512c0d369771136d872dd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hardware sync mode (hardware triggering)  <a href="group__streaming.html#ga8915d11aa512c0d369771136d872dd22">More...</a><br /></td></tr>
<tr class="separator:ga8915d11aa512c0d369771136d872dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b122d277193b04c819a39ea01e0a5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">hackrf_init_sweep</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, const uint16_t *frequency_list, const int num_ranges, const uint32_t num_bytes, const uint32_t step_width, const uint32_t offset, const enum <a class="el" href="group__streaming.html#gadd13ea4602d90423052eb55dafab007a">sweep_style</a> style)</td></tr>
<tr class="memdesc:ga05b122d277193b04c819a39ea01e0a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sweep mode.  <a href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">More...</a><br /></td></tr>
<tr class="separator:ga05b122d277193b04c819a39ea01e0a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d531271e2d568364d758e902514a11b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streaming.html#ga1d531271e2d568364d758e902514a11b">hackrf_start_rx_sweep</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, <a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a> callback, void *rx_ctx)</td></tr>
<tr class="memdesc:ga1d531271e2d568364d758e902514a11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start RX sweep.  <a href="group__streaming.html#ga1d531271e2d568364d758e902514a11b">More...</a><br /></td></tr>
<tr class="separator:ga1d531271e2d568364d758e902514a11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2><a class="anchor" id="autotoc_md31"></a>
Streaming</h2>
<p >There are 3 different streaming modes supported by HackRF:</p><ul>
<li>transmitting (TX)</li>
<li>receiving (RX)</li>
<li>swept receiving (SWEEP)</li>
</ul>
<p >Each mode needs to be initialized before use, then the mode needs to be entered with the <code>hackrf_start_*</code> function. Data transfer happens through callbacks.</p>
<p >There are 3 types of callbacks in the library:</p><ul>
<li>transfer callback</li>
<li>flush callback</li>
<li>block complete callback</li>
</ul>
<p >Steps for starting an RX or TX operation:</p><ul>
<li>initialize libhackrf</li>
<li>open device</li>
<li>setup device (frequency, samplerate, gain, etc)</li>
<li>setup callbacks, start operation (<code>hackrf_start_*</code>)</li>
<li>the main program should go to sleep</li>
<li>when done, the transfer callback should return non-zero value, and signal the main thread to stop</li>
<li>stop operation via <code>hackrf_stop_*</code></li>
<li>close device, exit library, etc.</li>
</ul>
<p >Data is transfered through the USB connection via setting up multiple async libusb transfers (<a class="el" href="group__library.html#gaee765b58fdb89c87fe60028e33ce581d">hackrf_get_transfer_queue_depth</a>). In TX mode, the transfers needs to be filled before submitting, and in RX mode, they need to be read out when they are done. This is done using the transfer callback - it receives a <a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> object and needs to transfer the data to/from it. As it's needed for all operations, this gets called whenever we need to move data, so every time a transfer is finished (and before the first transfer in TX mode). There's a "transfer complete callback" that only gets called when a transfer is completed. It does not need to do anything special tho, and is optional.</p>
<p >Streaming can be stopped via returning a non-zero value from the transfer callback, but that does NOT reset the device to IDLE mode, it only stops data transfers. In TX mode, when this happens, and the transmitter runs out of data to transmit, it will start transmitting all 0 values (but in older firmware versions, it started repeating the last buffer). To actually stop the operation, a call to <code>hackrf_stop_*</code> is needed. Since the callback operate in an async libusb context, such a call can't be made from there, only from the main thread, so it must be signaled through some means (for example, a global variable, or better, a <code>pthread_cond</code>) to stop. In RX mode, this signaling can be done from the transfer callback, but in TX mode, we must make sure that we only stop the operation when the last transfer is completed and the device transmitted it, or we might lose it. For this reason, the third <b>flush callback</b> exists, that gets called when this happens. It is adivsed to only signal the main thread to stop from this callback.</p>
<p >The function <a class="el" href="group__streaming.html#gad8cc13d8d4fd29d0e4e2b7e31f55603b">hackrf_is_streaming</a> can be used to check if the device is streaming or not.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
Transfer callback</h3>
<p >Set when starting an operation with <a class="el" href="group__streaming.html#gab06dfb4e0f16868d05d941e4f3bb5d87">hackrf_start_tx</a>, <a class="el" href="group__streaming.html#ga5960330666b4bf32aa49beb7780f44fe">hackrf_start_rx</a> or <a class="el" href="group__streaming.html#ga1d531271e2d568364d758e902514a11b">hackrf_start_rx_sweep</a>. This callback supplies / receives data. This function takes a <a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> struct as a parameter, and fill/read data to/from its buffer. This function runs in an async libusb context, meaning it should not iteract with the libhackrf library in other ways. The callback can return a boolean value, if its return value is non-zero then it won't be called again, meaning that no future transfers will take place, and (in TX case) the flush callback will be called shortly.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Block complete callback</h3>
<p >This callback is optional, and only applicable in TX mode. It gets called whenever a data transfer is finished, and can read the data. It needs to do nothing at all. This callback can be set using <a class="el" href="group__streaming.html#gab905e4d999ee5f35e8911d18ef250d5b">hackrf_set_tx_block_complete_callback</a></p>
<h3><a class="anchor" id="autotoc_md34"></a>
Flush callback</h3>
<p >This callback is optional, and only applicable in TX mode. It get called when the last transfer is completed, and it's advisable to only stop streaming via this callback. This callback can be set using <a class="el" href="group__streaming.html#ga677baa64e0aebf3cd38b65633b920cfe">hackrf_enable_tx_flush</a></p>
<h3><a class="anchor" id="autotoc_md35"></a>
Example TX code utilizing the transfer and flush callbacks.</h3>
<div class="fragment"><div class="line"><span class="comment">// Transmit a 440Hz triangle wave through FM (144.5MHz) using the libhackrf API </span></div>
<div class="line"><span class="comment">// Copyright (c) 2022 László Baráth &quot;Uncle Dino&quot; HA7DN &lt;https://github.com/Sasszem&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;libhackrf/hackrf.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pthread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;complex.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mod = 440;</div>
<div class="line"><span class="keyword">const</span> uint64_t sample_rate = 10000000;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> triangle() {</div>
<div class="line">    <span class="comment">// Generate an f_mod frequency triangle wave in the -1 - 1 region</span></div>
<div class="line">    <span class="comment">// each call to this function generates a single sample</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">double</span> state;</div>
<div class="line">    <span class="keyword">static</span> uint64_t samples_generated;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> uint64_t period_in_samples = sample_rate / f_mod;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step = 4.0 / period_in_samples; <span class="comment">// we need to go from -1 to 1 in half the period</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (samples_generated &lt; period_in_samples / 2 )</div>
<div class="line">        state += step;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        state -= step;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// this way we don&#39;t need to modulo it</span></div>
<div class="line">    <span class="keywordflow">if</span> (samples_generated ++ == period_in_samples)</div>
<div class="line">        samples_generated = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> state - 1.0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">volatile</span> <span class="keywordtype">double</span> complex phasor = 1.0;</div>
<div class="line"><span class="keywordtype">int</span> xfered_samples = 0;</div>
<div class="line"><span class="keywordtype">int</span> samples_to_xfer = 5*sample_rate;</div>
<div class="line"><span class="keyword">volatile</span> <span class="keywordtype">int</span> should_stop = 0;</div>
<div class="line"> </div>
<div class="line">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</div>
<div class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> transfer_callback(<a class="code hl_struct" href="structhackrf__transfer.html">hackrf_transfer</a> *transfer) {</div>
<div class="line">    int8_t *signed_buffer = (int8_t*)transfer-&gt;<a class="code hl_variable" href="structhackrf__transfer.html#a88d1d91a12f0226250a4784101717ba3">buffer</a>;</div>
<div class="line">    for (<span class="keywordtype">int</span> i = 0; i&lt;transfer-&gt;<a class="code hl_variable" href="structhackrf__transfer.html#a1b98fe1301eacde6c7184f4949610795">buffer_length</a>; i+=2) {</div>
<div class="line">        phasor *= cexp(I*6.28*3000 / sample_rate*triangle());</div>
<div class="line">        <span class="comment">// any IQ samples can be written here, now I&#39;m doing FM modulation with a triangle wave</span></div>
<div class="line">        signed_buffer[i] = 128 * creal(phasor);</div>
<div class="line">        signed_buffer[i+1] = 128 * cimag(phasor);</div>
<div class="line">    }</div>
<div class="line">    transfer-&gt;<a class="code hl_variable" href="structhackrf__transfer.html#aa2345b6101874e5275e54f4905071fc9">valid_length</a> = transfer-&gt;<a class="code hl_variable" href="structhackrf__transfer.html#a1b98fe1301eacde6c7184f4949610795">buffer_length</a>;</div>
<div class="line">    xfered_samples += transfer-&gt;<a class="code hl_variable" href="structhackrf__transfer.html#a1b98fe1301eacde6c7184f4949610795">buffer_length</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (xfered_samples &gt;= samples_to_xfer) {</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> flush_callback(<a class="code hl_struct" href="structhackrf__transfer.html">hackrf_transfer</a> *transfer) {</div>
<div class="line">    pthread_mutex_lock(&amp;mutex);</div>
<div class="line">    pthread_cond_broadcast(&amp;cond);</div>
<div class="line">    pthread_mutex_unlock(&amp;mutex);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {        </div>
<div class="line">    <a class="code hl_function" href="group__library.html#ga24671642e9b4cda76a73ff5dd867d53e">hackrf_init</a>();</div>
<div class="line">    <a class="code hl_typedef" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__device.html#ga83210c35d721de9ce9fd448b93ac5b34">hackrf_open</a>(&amp;device);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="group__configuration.html#gabfd8a2fa6ad65ddffcb9c924cae11c48">hackrf_set_freq</a>(device, 144500000);</div>
<div class="line">    <a class="code hl_function" href="group__configuration.html#gaa560229105044e9d9a3aa2347ebb31a6">hackrf_set_sample_rate</a>(device, 10000000);</div>
<div class="line">    <a class="code hl_function" href="group__configuration.html#gaa718bddc5acbf7573f3bcf6f8d7840ef">hackrf_set_amp_enable</a>(device, 1);</div>
<div class="line">    <a class="code hl_function" href="group__configuration.html#gac34fb435da15e3f9f49fbe5ee6df4564">hackrf_set_txvga_gain</a>(device, 20);</div>
<div class="line">    <span class="comment">// hackrf_set_tx_underrun_limit(device, 100000); // new-ish library function, not always available</span></div>
<div class="line">    <a class="code hl_function" href="group__streaming.html#ga677baa64e0aebf3cd38b65633b920cfe">hackrf_enable_tx_flush</a>(device, flush_callback, NULL);</div>
<div class="line">    <a class="code hl_function" href="group__streaming.html#gab06dfb4e0f16868d05d941e4f3bb5d87">hackrf_start_tx</a>(device, transfer_callback, NULL);</div>
<div class="line"> </div>
<div class="line">    pthread_mutex_lock(&amp;mutex);</div>
<div class="line">    pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// wait fo transfer to complete</span></div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="group__streaming.html#ga15a1632c1863cb02cece8d328d809c71">hackrf_stop_tx</a>(device);</div>
<div class="line">    <a class="code hl_function" href="group__device.html#ga00c1aad444514beac9fc1f97be4170e7">hackrf_close</a>(device);</div>
<div class="line">    <a class="code hl_function" href="group__library.html#ga5b4e9ba05cc466439628c5c588f96356">hackrf_exit</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__configuration_html_gaa560229105044e9d9a3aa2347ebb31a6"><div class="ttname"><a href="group__configuration.html#gaa560229105044e9d9a3aa2347ebb31a6">hackrf_set_sample_rate</a></div><div class="ttdeci">int hackrf_set_sample_rate(hackrf_device *device, const double freq_hz)</div><div class="ttdoc">Set sample rate.</div></div>
<div class="ttc" id="agroup__configuration_html_gaa718bddc5acbf7573f3bcf6f8d7840ef"><div class="ttname"><a href="group__configuration.html#gaa718bddc5acbf7573f3bcf6f8d7840ef">hackrf_set_amp_enable</a></div><div class="ttdeci">int hackrf_set_amp_enable(hackrf_device *device, const uint8_t value)</div><div class="ttdoc">Enable/disable 14dB RF amplifier.</div></div>
<div class="ttc" id="agroup__configuration_html_gabfd8a2fa6ad65ddffcb9c924cae11c48"><div class="ttname"><a href="group__configuration.html#gabfd8a2fa6ad65ddffcb9c924cae11c48">hackrf_set_freq</a></div><div class="ttdeci">int hackrf_set_freq(hackrf_device *device, const uint64_t freq_hz)</div><div class="ttdoc">Set the center frequency.</div></div>
<div class="ttc" id="agroup__configuration_html_gac34fb435da15e3f9f49fbe5ee6df4564"><div class="ttname"><a href="group__configuration.html#gac34fb435da15e3f9f49fbe5ee6df4564">hackrf_set_txvga_gain</a></div><div class="ttdeci">int hackrf_set_txvga_gain(hackrf_device *device, uint32_t value)</div><div class="ttdoc">Set RF TX gain of the MAX2837 transceiver IC (&quot;IF&quot; or &quot;VGA&quot; gain setting) in decibels.</div></div>
<div class="ttc" id="agroup__device_html_ga00c1aad444514beac9fc1f97be4170e7"><div class="ttname"><a href="group__device.html#ga00c1aad444514beac9fc1f97be4170e7">hackrf_close</a></div><div class="ttdeci">int hackrf_close(hackrf_device *device)</div><div class="ttdoc">Close a previously opened device.</div></div>
<div class="ttc" id="agroup__device_html_ga83210c35d721de9ce9fd448b93ac5b34"><div class="ttname"><a href="group__device.html#ga83210c35d721de9ce9fd448b93ac5b34">hackrf_open</a></div><div class="ttdeci">int hackrf_open(hackrf_device **device)</div><div class="ttdoc">Open first available HackRF device.</div></div>
<div class="ttc" id="agroup__device_html_ga90ad9cde4dfa282829aba292b24976b4"><div class="ttname"><a href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a></div><div class="ttdeci">struct hackrf_device hackrf_device</div><div class="ttdoc">Opaque struct for hackrf device info.</div><div class="ttdef"><b>Definition:</b> hackrf.h:858</div></div>
<div class="ttc" id="agroup__library_html_ga24671642e9b4cda76a73ff5dd867d53e"><div class="ttname"><a href="group__library.html#ga24671642e9b4cda76a73ff5dd867d53e">hackrf_init</a></div><div class="ttdeci">int hackrf_init()</div><div class="ttdoc">Initialize libhackrf.</div></div>
<div class="ttc" id="agroup__library_html_ga5b4e9ba05cc466439628c5c588f96356"><div class="ttname"><a href="group__library.html#ga5b4e9ba05cc466439628c5c588f96356">hackrf_exit</a></div><div class="ttdeci">int hackrf_exit()</div><div class="ttdoc">Exit libhackrf.</div></div>
<div class="ttc" id="agroup__streaming_html_ga15a1632c1863cb02cece8d328d809c71"><div class="ttname"><a href="group__streaming.html#ga15a1632c1863cb02cece8d328d809c71">hackrf_stop_tx</a></div><div class="ttdeci">int hackrf_stop_tx(hackrf_device *device)</div><div class="ttdoc">Stop transmission.</div></div>
<div class="ttc" id="agroup__streaming_html_ga677baa64e0aebf3cd38b65633b920cfe"><div class="ttname"><a href="group__streaming.html#ga677baa64e0aebf3cd38b65633b920cfe">hackrf_enable_tx_flush</a></div><div class="ttdeci">int hackrf_enable_tx_flush(hackrf_device *device, hackrf_flush_cb_fn callback, void *flush_ctx)</div><div class="ttdoc">Setup flush (end-of-transmission) callback.</div></div>
<div class="ttc" id="agroup__streaming_html_gab06dfb4e0f16868d05d941e4f3bb5d87"><div class="ttname"><a href="group__streaming.html#gab06dfb4e0f16868d05d941e4f3bb5d87">hackrf_start_tx</a></div><div class="ttdeci">int hackrf_start_tx(hackrf_device *device, hackrf_sample_block_cb_fn callback, void *tx_ctx)</div><div class="ttdoc">Start transmitting.</div></div>
<div class="ttc" id="astructhackrf__transfer_html"><div class="ttname"><a href="structhackrf__transfer.html">hackrf_transfer</a></div><div class="ttdoc">USB transfer information passed to RX or TX callback.</div><div class="ttdef"><b>Definition:</b> hackrf.h:867</div></div>
<div class="ttc" id="astructhackrf__transfer_html_a1b98fe1301eacde6c7184f4949610795"><div class="ttname"><a href="structhackrf__transfer.html#a1b98fe1301eacde6c7184f4949610795">hackrf_transfer::buffer_length</a></div><div class="ttdeci">int buffer_length</div><div class="ttdoc">length of data buffer in bytes</div><div class="ttdef"><b>Definition:</b> hackrf.h:873</div></div>
<div class="ttc" id="astructhackrf__transfer_html_a88d1d91a12f0226250a4784101717ba3"><div class="ttname"><a href="structhackrf__transfer.html#a88d1d91a12f0226250a4784101717ba3">hackrf_transfer::buffer</a></div><div class="ttdeci">uint8_t * buffer</div><div class="ttdoc">transfer data buffer (interleaved 8 bit I/Q samples)</div><div class="ttdef"><b>Definition:</b> hackrf.h:871</div></div>
<div class="ttc" id="astructhackrf__transfer_html_aa2345b6101874e5275e54f4905071fc9"><div class="ttname"><a href="structhackrf__transfer.html#aa2345b6101874e5275e54f4905071fc9">hackrf_transfer::valid_length</a></div><div class="ttdeci">int valid_length</div><div class="ttdoc">number of buffer bytes that were transferred</div><div class="ttdef"><b>Definition:</b> hackrf.h:875</div></div>
</div><!-- fragment --><p >This code can be compiled using <code>gcc -o triangle triangle.c -lm -lhackrf</code>. It generates and transmits a 440Hz triangle wave using FM modulation on the 2m HAM band (<b>check your local laws and regulations on transmitting and only transmit on bands you have license to!</b>).</p>
<p >For a more complete example, including error handling and more settings, see <a href="https://github.com/greatscottgadgets/hackrf/blob/master/host/hackrf-tools/src/hackrf_transfer.c">hackrf_transfer.c</a></p>
<h2><a class="anchor" id="autotoc_md36"></a>
Underrun and overrun</h2>
<p >Underrun/overrun detection can be enabled using <a class="el" href="group__streaming.html#ga9037db244680c7dd5dac0abe4d2fb4a5">hackrf_set_tx_underrun_limit</a> or <a class="el" href="group__streaming.html#gad10eb6ec19afb5b137cc93926c324593">hackrf_set_rx_overrun_limit</a> limit. This causes the HackRF to stop operation if more than the specified amount of samples get lost, for example in case of your program crashing, USB connection faliure, etc.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Sweeping</h2>
<p >Sweeping mode is kind of special. In this mode, the device can be programmed to a list of frequencies to tune on, record set amount of samples and then tune to the next frequency and repeat. It can be setup via <a class="el" href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">hackrf_init_sweep</a> and started with <a class="el" href="group__streaming.html#ga1d531271e2d568364d758e902514a11b">hackrf_start_rx_sweep</a>. In this mode, <b>the callback does not receive raw samples</b>, but blocks of samples prefixed with a frequency header specifying the tuned frequency.</p>
<p >See <a href="https://github.com/greatscottgadgets/hackrf/blob/master/host/hackrf-tools/src/hackrf_sweep.c#L236-L249">hackrf_sweep.c</a> for a full example, and especialy <a href="https://github.com/greatscottgadgets/hackrf/blob/eff4a20022ca5d7f11405c3cdeea6c4195e347d0/host/hackrf-tools/src/hackrf_sweep.c#L236-L249">the start of the RX callback</a> for parsing the frequency header.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
HW sync mode</h2>
<p ><a class="el" href="group__streaming.html#ga8915d11aa512c0d369771136d872dd22">hackrf_set_hw_sync_mode</a> can be used to setup HW sync mode (<a href="https://hackrf.readthedocs.io/en/latest/hardware_triggering.html">see the documentation on this mode</a>). This mode allows multiple HackRF Ones to synchronize operations, or one HackRF One to synchrnonize on an external trigger source. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga05c28f2a4b49e991e1fa97892e60e25f" name="ga05c28f2a4b49e991e1fa97892e60e25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c28f2a4b49e991e1fa97892e60e25f">&#9670;&nbsp;</a></span>BYTES_PER_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTES_PER_BLOCK&#160;&#160;&#160;16384</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac885702b61abc57399865ba062a46a52" name="gac885702b61abc57399865ba062a46a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac885702b61abc57399865ba062a46a52">&#9670;&nbsp;</a></span>MAX_SWEEP_RANGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_SWEEP_RANGES&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae581302423a0d3dd5a2e68139426ba06" name="gae581302423a0d3dd5a2e68139426ba06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae581302423a0d3dd5a2e68139426ba06">&#9670;&nbsp;</a></span>SAMPLES_PER_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAMPLES_PER_BLOCK&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga002023cc3bf3d961cd4664bd6f091f7b" name="ga002023cc3bf3d961cd4664bd6f091f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002023cc3bf3d961cd4664bd6f091f7b">&#9670;&nbsp;</a></span>hackrf_flush_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hackrf_flush_cb_fn) (void *flush_ctx, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Will be called when the last samples are transmitted and stopping transmission will result in no samples getting lost. Should signal the main thread that it should stop transmission via <a class="el" href="group__streaming.html#ga15a1632c1863cb02cece8d328d809c71">hackrf_stop_tx</a> </p>

</div>
</div>
<a id="ga338cc5b413e5706a3e1eb63bb292a6a3" name="ga338cc5b413e5706a3e1eb63bb292a6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338cc5b413e5706a3e1eb63bb292a6a3">&#9670;&nbsp;</a></span>hackrf_sample_block_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* hackrf_sample_block_cb_fn) (<a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> *transfer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >In each mode, it is called when data needs to be handled, meaning filling samples in TX mode or reading them in RX modes.</p>
<p >In TX mode, it should refill the transfer buffer with new raw IQ data, and set <a class="el" href="structhackrf__transfer.html#aa2345b6101874e5275e54f4905071fc9">hackrf_transfer::valid_length</a>.</p>
<p >In RX mode, it should copy/process the contents of the transfer buffer's valid part.</p>
<p >In RX SWEEP mode, it receives multiple "blocks" of data, each with a 10-byte header containing the tuned frequency followed by the samples. See <a class="el" href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">hackrf_init_sweep</a> for more info.</p>
<p >The callback should return 0 if it wants to be called again, and any other value otherwise. Stopping the RX/TX/SWEEP is still done with <a class="el" href="group__streaming.html#ga4725318ea54f83ca13a34ecc377d8072">hackrf_stop_rx</a> and <a class="el" href="group__streaming.html#ga15a1632c1863cb02cece8d328d809c71">hackrf_stop_tx</a>, and those should be called from the main thread, so this callback should signal the main thread that it should stop. Signaling the main thread to stop TX should be done from the flush callback in order to guarantee that no samples are discarded, see <a class="el" href="group__streaming.html#ga002023cc3bf3d961cd4664bd6f091f7b">hackrf_flush_cb_fn</a> </p>

</div>
</div>
<a id="ga34a8eb91144c6bf1a865b9a55092f33c" name="ga34a8eb91144c6bf1a865b9a55092f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a8eb91144c6bf1a865b9a55092f33c">&#9670;&nbsp;</a></span>hackrf_tx_block_complete_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hackrf_tx_block_complete_cb_fn) (<a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> *transfer, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set via <a class="el" href="group__streaming.html#gab905e4d999ee5f35e8911d18ef250d5b">hackrf_set_tx_block_complete_callback</a>, called when a transfer is finished to the device's buffer, regardless if the transfer was successful or not. It can signal the main thread to stop on failure, can catch USB transfer errors and can also gather statistics about the transfered data. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadd13ea4602d90423052eb55dafab007a" name="gadd13ea4602d90423052eb55dafab007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd13ea4602d90423052eb55dafab007a">&#9670;&nbsp;</a></span>sweep_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__streaming.html#gadd13ea4602d90423052eb55dafab007a">sweep_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used by <a class="el" href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">hackrf_init_sweep</a>, to set sweep parameters.</p>
<p >Linear mode is no longer used by the hackrf_sweep command line tool and in general the interleaved method is always preferable, but the linear mode remains available for backward compatibility and might be useful in some special circumstances. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd13ea4602d90423052eb55dafab007aadc101ebf31c49c2d4b80b7c6f59f22cb" name="ggadd13ea4602d90423052eb55dafab007aadc101ebf31c49c2d4b80b7c6f59f22cb"></a>LINEAR&#160;</td><td class="fielddoc"><p >step_width is added to the current frequency at each step. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd13ea4602d90423052eb55dafab007aaf59ecbbe3f314395e0ffa01b0f1f4e56" name="ggadd13ea4602d90423052eb55dafab007aaf59ecbbe3f314395e0ffa01b0f1f4e56"></a>INTERLEAVED&#160;</td><td class="fielddoc"><p >each step is divided into two interleaved sub-steps, allowing the host to select the best portions of the FFT of each sub-step and discard the rest. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga677baa64e0aebf3cd38b65633b920cfe" name="ga677baa64e0aebf3cd38b65633b920cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677baa64e0aebf3cd38b65633b920cfe">&#9670;&nbsp;</a></span>hackrf_enable_tx_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_enable_tx_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__streaming.html#ga002023cc3bf3d961cd4664bd6f091f7b">hackrf_flush_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>flush_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This callback will be called when all the data was transmitted and all data transfers were completed. First parameter is supplied context, second parameter is success flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">callback</td><td>callback to call when all transfers were completed </td></tr>
    <tr><td class="paramname">flush_ctx</td><td>context (1st parameter of callback) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga05b122d277193b04c819a39ea01e0a5b" name="ga05b122d277193b04c819a39ea01e0a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05b122d277193b04c819a39ea01e0a5b">&#9670;&nbsp;</a></span>hackrf_init_sweep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_init_sweep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>frequency_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>step_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__streaming.html#gadd13ea4602d90423052eb55dafab007a">sweep_style</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >In this mode, in a single data transfer (single call to the RX transfer callback), multiple blocks of size <code>num_bytes</code> bytes are received with different center frequencies. At the beginning of each block, a 10-byte frequency header is present in <code>0x7F - 0x7F - uint64_t frequency (LSBFIRST, in Hz)</code> format, followed by the actual samples.</p>
<p >Requires USB API version 0x0102 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">frequency_list</td><td>list of start-stop frequency pairs in MHz </td></tr>
    <tr><td class="paramname">num_ranges</td><td>length of array <code>frequency_list</code> (in pairs, so total array length / 2!). Must be less than <a class="el" href="group__streaming.html#gac885702b61abc57399865ba062a46a52">MAX_SWEEP_RANGES</a> </td></tr>
    <tr><td class="paramname">num_bytes</td><td>number of bytes to capture per tuning, must be a multiple of <a class="el" href="group__streaming.html#ga05c28f2a4b49e991e1fa97892e60e25f">BYTES_PER_BLOCK</a> </td></tr>
    <tr><td class="paramname">step_width</td><td>width of each tuning step in Hz </td></tr>
    <tr><td class="paramname">offset</td><td>frequency offset added to tuned frequencies. sample_rate / 2 is a good value </td></tr>
    <tr><td class="paramname">style</td><td>sweep style </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gad8cc13d8d4fd29d0e4e2b7e31f55603b" name="gad8cc13d8d4fd29d0e4e2b7e31f55603b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8cc13d8d4fd29d0e4e2b7e31f55603b">&#9670;&nbsp;</a></span>hackrf_is_streaming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_is_streaming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca9051ad1bfda5fd049a399cb7f727578f">HACKRF_TRUE</a> if the device is streaming, else one of <a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4caaf7cf91015031728126c9bdc3aa615a1">HACKRF_ERROR_STREAMING_THREAD_ERR</a>, <a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4cae2a83bc050b4a6fe8c29504d005704b8">HACKRF_ERROR_STREAMING_STOPPED</a> or <a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4cabee5d82c3a058b33c1494a22abb86123">HACKRF_ERROR_STREAMING_EXIT_CALLED</a> </dd></dl>

</div>
</div>
<a id="ga8915d11aa512c0d369771136d872dd22" name="ga8915d11aa512c0d369771136d872dd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8915d11aa512c0d369771136d872dd22">&#9670;&nbsp;</a></span>hackrf_set_hw_sync_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_set_hw_sync_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >See the documentation on hardware triggering for details</p>
<p >Requires USB API version 0x0102 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">value</td><td>enable (1) or disable (0) hardware triggering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gad10eb6ec19afb5b137cc93926c324593" name="gad10eb6ec19afb5b137cc93926c324593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10eb6ec19afb5b137cc93926c324593">&#9670;&nbsp;</a></span>hackrf_set_rx_overrun_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_set_rx_overrun_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >When this limit is set, after the specified number of samples (bytes, not whole IQ pairs) missing the device will automatically return to IDLE mode, thus stopping operation. Useful for handling cases like program/computer crashes or other problems. The default value 0 means no limit.</p>
<p >Requires USB API version 0x0106 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">value</td><td>number of samples to wait before auto-stopping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gab905e4d999ee5f35e8911d18ef250d5b" name="gab905e4d999ee5f35e8911d18ef250d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab905e4d999ee5f35e8911d18ef250d5b">&#9670;&nbsp;</a></span>hackrf_set_tx_block_complete_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_set_tx_block_complete_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__streaming.html#ga34a8eb91144c6bf1a865b9a55092f33c">hackrf_tx_block_complete_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This callback will be called whenever an USB transfer to the device is completed, regardless if it was successful or not (indicated by the second parameter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">callback</td><td>callback to call when a transfer is completed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga9037db244680c7dd5dac0abe4d2fb4a5" name="ga9037db244680c7dd5dac0abe4d2fb4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9037db244680c7dd5dac0abe4d2fb4a5">&#9670;&nbsp;</a></span>hackrf_set_tx_underrun_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_set_tx_underrun_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >When this limit is set, after the specified number of samples (bytes, not whole IQ pairs) missing the device will automatically return to IDLE mode, thus stopping operation. Useful for handling cases like program/computer crashes or other problems. The default value 0 means no limit.</p>
<p >Requires USB API version 0x0106 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">value</td><td>number of samples to wait before auto-stopping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant <br  />
 </dd></dl>

</div>
</div>
<a id="ga5960330666b4bf32aa49beb7780f44fe" name="ga5960330666b4bf32aa49beb7780f44fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5960330666b4bf32aa49beb7780f44fe">&#9670;&nbsp;</a></span>hackrf_start_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_start_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rx_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should be called after setting gains, frequency and sampling rate, as these values won't get reset but instead keep their last value, thus their state is unknown.</p>
<p >The callback is called with a <a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> object whenever the buffer is full. The callback is called in an async context so no libhackrf functions should be called from it. The callback should treat its argument as read-only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">callback</td><td>rx_callback </td></tr>
    <tr><td class="paramname">rx_ctx</td><td>User provided RX context. Not used by the library, but available to <code>callback</code> as <a class="el" href="structhackrf__transfer.html#a3ee96e8bbf002ae8c13614f42a6c7945">hackrf_transfer::rx_ctx</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga1d531271e2d568364d758e902514a11b" name="ga1d531271e2d568364d758e902514a11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d531271e2d568364d758e902514a11b">&#9670;&nbsp;</a></span>hackrf_start_rx_sweep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_start_rx_sweep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rx_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >See <a class="el" href="group__streaming.html#ga05b122d277193b04c819a39ea01e0a5b">hackrf_init_sweep</a> for more info</p>
<p >Requires USB API version 0x0104 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to start sweeping </td></tr>
    <tr><td class="paramname">callback</td><td>rx callback processing the received data </td></tr>
    <tr><td class="paramname">rx_ctx</td><td>User provided RX context. Not used by the library, but available to <code>callback</code> as <a class="el" href="structhackrf__transfer.html#a3ee96e8bbf002ae8c13614f42a6c7945">hackrf_transfer::rx_ctx</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gab06dfb4e0f16868d05d941e4f3bb5d87" name="gab06dfb4e0f16868d05d941e4f3bb5d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab06dfb4e0f16868d05d941e4f3bb5d87">&#9670;&nbsp;</a></span>hackrf_start_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_start_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__streaming.html#ga338cc5b413e5706a3e1eb63bb292a6a3">hackrf_sample_block_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tx_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should be called after setting gains, frequency and sampling rate, as these values won't get reset but instead keep their last value, thus their state is unknown. Setting flush function (using <a class="el" href="group__streaming.html#ga677baa64e0aebf3cd38b65633b920cfe">hackrf_enable_tx_flush</a>) and/or setting block complete callback (using <a class="el" href="group__streaming.html#gab905e4d999ee5f35e8911d18ef250d5b">hackrf_set_tx_block_complete_callback</a>) (if these features are used) should also be done before this.</p>
<p >The callback is called with a <a class="el" href="structhackrf__transfer.html">hackrf_transfer</a> object whenever a transfer buffer is needed to be filled with samples. The callback is called in an async context so no libhackrf functions should be called from it. The callback should treat its argument as read-only, except the <a class="el" href="structhackrf__transfer.html#a88d1d91a12f0226250a4784101717ba3">hackrf_transfer::buffer</a> and <a class="el" href="structhackrf__transfer.html#aa2345b6101874e5275e54f4905071fc9">hackrf_transfer::valid_length</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">callback</td><td>tx_callback </td></tr>
    <tr><td class="paramname">tx_ctx</td><td>User provided TX context. Not used by the library, but available to <code>callback</code> as <a class="el" href="structhackrf__transfer.html#afc610fbe9d139fda8ba9166405cffd85">hackrf_transfer::tx_ctx</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga4725318ea54f83ca13a34ecc377d8072" name="ga4725318ea54f83ca13a34ecc377d8072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4725318ea54f83ca13a34ecc377d8072">&#9670;&nbsp;</a></span>hackrf_stop_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_stop_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to stop RX on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga15a1632c1863cb02cece8d328d809c71" name="ga15a1632c1863cb02cece8d328d809c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a1632c1863cb02cece8d328d809c71">&#9670;&nbsp;</a></span>hackrf_stop_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_stop_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to stop TX on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
