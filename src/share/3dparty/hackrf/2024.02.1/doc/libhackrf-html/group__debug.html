<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libhackrf: Firmware flashing &amp; debugging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libhackrf
   </div>
   <div id="projectbrief">HackRF SDR platform library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Firmware flashing &amp; debugging</div></div>
</div><!--header-->
<div class="contents">

<p>Firmware flashing and directly accessing hardware components.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhackrf__m0__state.html">hackrf_m0_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the SGPIO loop running on the M0 core.  <a href="structhackrf__m0__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafe86c3460380c4c3114eed863215750f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gafe86c3460380c4c3114eed863215750f">hackrf_get_m0_state</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, <a class="el" href="structhackrf__m0__state.html">hackrf_m0_state</a> *value)</td></tr>
<tr class="memdesc:gafe86c3460380c4c3114eed863215750f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state of the M0 code on the LPC43xx MCU.  <a href="group__debug.html#gafe86c3460380c4c3114eed863215750f">More...</a><br /></td></tr>
<tr class="separator:gafe86c3460380c4c3114eed863215750f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3409fe363804781570d6cc5fdfa5ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga0a3409fe363804781570d6cc5fdfa5ab">hackrf_max2837_read</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint8_t register_number, uint16_t *value)</td></tr>
<tr class="memdesc:ga0a3409fe363804781570d6cc5fdfa5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly read the registers of the MAX2837 transceiver IC.  <a href="group__debug.html#ga0a3409fe363804781570d6cc5fdfa5ab">More...</a><br /></td></tr>
<tr class="separator:ga0a3409fe363804781570d6cc5fdfa5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e92aed0b2441f874224e5bdb0fdc1d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga4e92aed0b2441f874224e5bdb0fdc1d2">hackrf_max2837_write</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint8_t register_number, uint16_t value)</td></tr>
<tr class="memdesc:ga4e92aed0b2441f874224e5bdb0fdc1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly write the registers of the MAX2837 transceiver IC.  <a href="group__debug.html#ga4e92aed0b2441f874224e5bdb0fdc1d2">More...</a><br /></td></tr>
<tr class="separator:ga4e92aed0b2441f874224e5bdb0fdc1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2493ce06c70328ebbedc1814a1e0e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gacd2493ce06c70328ebbedc1814a1e0e8">hackrf_si5351c_read</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint16_t register_number, uint16_t *value)</td></tr>
<tr class="memdesc:gacd2493ce06c70328ebbedc1814a1e0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly read the registers of the Si5351C clock generator IC.  <a href="group__debug.html#gacd2493ce06c70328ebbedc1814a1e0e8">More...</a><br /></td></tr>
<tr class="separator:gacd2493ce06c70328ebbedc1814a1e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49e5c7c35e6443d9c4acc3d68fe43597"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga49e5c7c35e6443d9c4acc3d68fe43597">hackrf_si5351c_write</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint16_t register_number, uint16_t value)</td></tr>
<tr class="memdesc:ga49e5c7c35e6443d9c4acc3d68fe43597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly write the registers of the Si5351 clock generator IC.  <a href="group__debug.html#ga49e5c7c35e6443d9c4acc3d68fe43597">More...</a><br /></td></tr>
<tr class="separator:ga49e5c7c35e6443d9c4acc3d68fe43597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e1a305e83dab98326b5d6a390304cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga57e1a305e83dab98326b5d6a390304cd">hackrf_rffc5071_read</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint8_t register_number, uint16_t *value)</td></tr>
<tr class="memdesc:ga57e1a305e83dab98326b5d6a390304cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly read the registers of the RFFC5071/5072 mixer-synthesizer IC.  <a href="group__debug.html#ga57e1a305e83dab98326b5d6a390304cd">More...</a><br /></td></tr>
<tr class="separator:ga57e1a305e83dab98326b5d6a390304cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc929dc89cad14005800d8802d717556"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gafc929dc89cad14005800d8802d717556">hackrf_rffc5071_write</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint8_t register_number, uint16_t value)</td></tr>
<tr class="memdesc:gafc929dc89cad14005800d8802d717556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly write the registers of the RFFC5071/5072 mixer-synthesizer IC.  <a href="group__debug.html#gafc929dc89cad14005800d8802d717556">More...</a><br /></td></tr>
<tr class="separator:gafc929dc89cad14005800d8802d717556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e1e571ac6928f4c1d32cf8cc817231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga01e1e571ac6928f4c1d32cf8cc817231">hackrf_spiflash_erase</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device)</td></tr>
<tr class="memdesc:ga01e1e571ac6928f4c1d32cf8cc817231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase firmware image on the SPI flash.  <a href="group__debug.html#ga01e1e571ac6928f4c1d32cf8cc817231">More...</a><br /></td></tr>
<tr class="separator:ga01e1e571ac6928f4c1d32cf8cc817231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee2de669983c9f8d19a52ccb973d3d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga0ee2de669983c9f8d19a52ccb973d3d9">hackrf_spiflash_write</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, const uint32_t address, const uint16_t length, unsigned char *const data)</td></tr>
<tr class="memdesc:ga0ee2de669983c9f8d19a52ccb973d3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write firmware image on the SPI flash.  <a href="group__debug.html#ga0ee2de669983c9f8d19a52ccb973d3d9">More...</a><br /></td></tr>
<tr class="separator:ga0ee2de669983c9f8d19a52ccb973d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f53bdd987e128c344f883fea211da98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga6f53bdd987e128c344f883fea211da98">hackrf_spiflash_read</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, const uint32_t address, const uint16_t length, unsigned char *data)</td></tr>
<tr class="memdesc:ga6f53bdd987e128c344f883fea211da98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read firmware image on the SPI flash.  <a href="group__debug.html#ga6f53bdd987e128c344f883fea211da98">More...</a><br /></td></tr>
<tr class="separator:ga6f53bdd987e128c344f883fea211da98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d4d66e7b47b069fa8db06b7ec46679"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga91d4d66e7b47b069fa8db06b7ec46679">hackrf_spiflash_status</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, uint8_t *data)</td></tr>
<tr class="memdesc:ga91d4d66e7b47b069fa8db06b7ec46679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the status registers of the W25Q80BV SPI flash chip.  <a href="group__debug.html#ga91d4d66e7b47b069fa8db06b7ec46679">More...</a><br /></td></tr>
<tr class="separator:ga91d4d66e7b47b069fa8db06b7ec46679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7622cee345a7963a6445943f1b82215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gad7622cee345a7963a6445943f1b82215">hackrf_spiflash_clear_status</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device)</td></tr>
<tr class="memdesc:gad7622cee345a7963a6445943f1b82215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the status registers of the W25Q80BV SPI flash chip.  <a href="group__debug.html#gad7622cee345a7963a6445943f1b82215">More...</a><br /></td></tr>
<tr class="separator:gad7622cee345a7963a6445943f1b82215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba4c20dfdaa2a410a7161180cc5da6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gafba4c20dfdaa2a410a7161180cc5da6c">hackrf_cpld_write</a> (<a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *device, unsigned char *const data, const unsigned int total_length)</td></tr>
<tr class="memdesc:gafba4c20dfdaa2a410a7161180cc5da6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write configuration bitstream into the XC2C64A-7VQ100C CPLD.  <a href="group__debug.html#gafba4c20dfdaa2a410a7161180cc5da6c">More...</a><br /></td></tr>
<tr class="separator:gafba4c20dfdaa2a410a7161180cc5da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="autotoc_md39"></a>
Firmware flashing</h1>
<p ><b>IMPORTANT</b> You should try to use the existing flashing utilities (<code>hackrf_spiflash</code>) to flash new firmware to the device! Incorrect usage of the SPIFLASH functions (especially <a class="el" href="group__debug.html#ga01e1e571ac6928f4c1d32cf8cc817231">hackrf_spiflash_erase</a> an <a class="el" href="group__debug.html#ga0ee2de669983c9f8d19a52ccb973d3d9">hackrf_spiflash_write</a>) can brick the device, and DFU mode will be needed to unbrick it!</p>
<p >Firmware flashing can be achieved via writing to the SPI flash holding the firmware of the ARM microcontroller. This can be achieved by the <code>hackrf_spiflash_*</code> functions.</p>
<p >The Spartan II CPLD inside the HackRF One devices could also be reconfigured in the past, but in newer firmwares, the ARM MCU automatically reconfigures it on startup with a bitstream baked into the firmware image, thus the function <a class="el" href="group__debug.html#gafba4c20dfdaa2a410a7161180cc5da6c">hackrf_cpld_write</a> has no effect, and CPLD flashing can only be done by building a custom firmware (or the automatic loading can be disabled this way as well). The function <a class="el" href="group__debug.html#gafba4c20dfdaa2a410a7161180cc5da6c">hackrf_cpld_write</a> and the util <code>hackrf_cpldjtag</code> are <b>deprecated</b> and only kept for backward compatibility with older firmware versions.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Debugging</h1>
<p >The functions in this section can be used to directly read/write internal registers of the chips inside a HackRF One unit. See the page <a href="https://hackrf.readthedocs.io/en/latest/hardware_components.html">Hardware Components</a> for more details on them.</p>
<p >Here's a brief introduction on the various chips in the HackRF One unit:</p>
<h2><a class="anchor" id="autotoc_md41"></a>
MAX2837 2.3 to 2.7 GHz transceiver</h2>
<p >This transceiver chip is the RF modulator/demodulator of the HackRF One. This chip sends/receives analoge I/Q samples to/from the MAX5864 ADC/DAC chip.</p>
<p >Its registers are accessible through the functions <a class="el" href="group__debug.html#ga0a3409fe363804781570d6cc5fdfa5ab">hackrf_max2837_read</a> and <a class="el" href="group__debug.html#ga4e92aed0b2441f874224e5bdb0fdc1d2">hackrf_max2837_write</a></p>
<h2><a class="anchor" id="autotoc_md42"></a>
MAX5864 ADC/DAC</h2>
<p >This chip converts received analgoe I/Q samples to digital and transmitted I/Q samples to analoge. It connects to the main ARM MCU through the CPLD. No configuration is needed for it, only the sample rate can be set via the clock generator IC.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Si5351C Clock generator</h2>
<p >This chip supplies clock signals to all of the other chips. It can synthesize a wide range of frequencies from its clock inputs (internal or external). It uses a fixed 800-MHz internal clock (synthesized via a PLL).</p>
<p >Its registers are accessible through the functions <a class="el" href="group__debug.html#gacd2493ce06c70328ebbedc1814a1e0e8">hackrf_si5351c_read</a> and <a class="el" href="group__debug.html#ga49e5c7c35e6443d9c4acc3d68fe43597">hackrf_si5351c_write</a></p>
<h2><a class="anchor" id="autotoc_md44"></a>
RFFC5072 Synthesizer/mixer</h2>
<p >This mixer mixes the RF signal with an internally synthesized local oscillator signal and thus results in the sum and difference frequencies. Combined with the LPF or HPF filters and the frequency setting in the MAX2837 IC it can be used to tune to any frequency in the 0-6000MHz range.</p>
<p >Its registers are accessible through the functions <a class="el" href="group__debug.html#ga57e1a305e83dab98326b5d6a390304cd">hackrf_rffc5071_read</a> and <a class="el" href="group__debug.html#gafc929dc89cad14005800d8802d717556">hackrf_rffc5071_write</a></p>
<h2><a class="anchor" id="autotoc_md45"></a>
LPC4320 ARM MCU</h2>
<p >This is the main processor of the unit. It's a multi-core ARM processor. It's configured to boot from a W25Q80B SPI flash, but can also be booted from DFU in order to unbrick a bricked unit. It communicated with the host PC via USB.</p>
<p >Some operation details are available via the function <a class="el" href="group__debug.html#gafe86c3460380c4c3114eed863215750f">hackrf_get_m0_state</a></p>
<h2><a class="anchor" id="autotoc_md46"></a>
W25Q80B SPI flash</h2>
<p >This chip holds the firmware for the LPC4320 ARM MCU.</p>
<p >It's accessible through the functions <a class="el" href="group__debug.html#ga6f53bdd987e128c344f883fea211da98">hackrf_spiflash_read</a>, <a class="el" href="group__debug.html#ga0ee2de669983c9f8d19a52ccb973d3d9">hackrf_spiflash_write</a>, <a class="el" href="group__debug.html#ga01e1e571ac6928f4c1d32cf8cc817231">hackrf_spiflash_erase</a>, <a class="el" href="group__debug.html#ga91d4d66e7b47b069fa8db06b7ec46679">hackrf_spiflash_status</a> and <a class="el" href="group__debug.html#gad7622cee345a7963a6445943f1b82215">hackrf_spiflash_clear_status</a></p>
<h2><a class="anchor" id="autotoc_md47"></a>
XC2C64A CPLD</h2>
<p >This CPLD sits between the MAX5864 ADC/DAC and the main MCU, and mainly performs data format conversion and some synchronisation.</p>
<p >Its bitstream is auto-loaded on reset by the ARM MCU (from the firmware image), but in older versions, it was possible to reconfigure it via <a class="el" href="group__debug.html#gafba4c20dfdaa2a410a7161180cc5da6c">hackrf_cpld_write</a>, and the (since temporarly removed) <code>hackrf_cpld_checksum</code> function could verify the firmware in the configuration flash (again, overwritten on startup, so irrelevant).</p>
<p >See <a href="https://github.com/greatscottgadgets/hackrf/issues/609">issue 608</a>, <a href="https://github.com/greatscottgadgets/hackrf/issues/1140">issue 1140</a> and <a href="https://github.com/greatscottgadgets/hackrf/issues/1141">issue 1141</a> for some more details on this! </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafba4c20dfdaa2a410a7161180cc5da6c" name="gafba4c20dfdaa2a410a7161180cc5da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafba4c20dfdaa2a410a7161180cc5da6c">&#9670;&nbsp;</a></span>hackrf_cpld_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_cpld_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>total_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to configure </td></tr>
    <tr><td class="paramname">data</td><td>CPLD bitstream data </td></tr>
    <tr><td class="paramname">total_length</td><td>length of the bitstream to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gafe86c3460380c4c3114eed863215750f" name="gafe86c3460380c4c3114eed863215750f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe86c3460380c4c3114eed863215750f">&#9670;&nbsp;</a></span>hackrf_get_m0_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_get_m0_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhackrf__m0__state.html">hackrf_m0_state</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Requires USB API version 0x0106 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>MCU code state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant <br  />
 </dd></dl>

</div>
</div>
<a id="ga0a3409fe363804781570d6cc5fdfa5ab" name="ga0a3409fe363804781570d6cc5fdfa5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3409fe363804781570d6cc5fdfa5ab">&#9670;&nbsp;</a></span>hackrf_max2837_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_max2837_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intended for debugging purposes only!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">register_number</td><td>register number to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value of the specified register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga4e92aed0b2441f874224e5bdb0fdc1d2" name="ga4e92aed0b2441f874224e5bdb0fdc1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e92aed0b2441f874224e5bdb0fdc1d2">&#9670;&nbsp;</a></span>hackrf_max2837_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_max2837_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intended for debugging purposes only!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to write </td></tr>
    <tr><td class="paramname">register_number</td><td>register number to write </td></tr>
    <tr><td class="paramname">value</td><td>value to write in the specified register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga57e1a305e83dab98326b5d6a390304cd" name="ga57e1a305e83dab98326b5d6a390304cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57e1a305e83dab98326b5d6a390304cd">&#9670;&nbsp;</a></span>hackrf_rffc5071_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_rffc5071_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intended for debugging purposes only!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">register_number</td><td>register number to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value of the specified register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gafc929dc89cad14005800d8802d717556" name="gafc929dc89cad14005800d8802d717556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc929dc89cad14005800d8802d717556">&#9670;&nbsp;</a></span>hackrf_rffc5071_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_rffc5071_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intended for debugging purposes only!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">register_number</td><td>register number to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value to write in the specified register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gacd2493ce06c70328ebbedc1814a1e0e8" name="gacd2493ce06c70328ebbedc1814a1e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd2493ce06c70328ebbedc1814a1e0e8">&#9670;&nbsp;</a></span>hackrf_si5351c_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_si5351c_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intended for debugging purposes only!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">register_number</td><td>register number to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value of the specified register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga49e5c7c35e6443d9c4acc3d68fe43597" name="ga49e5c7c35e6443d9c4acc3d68fe43597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49e5c7c35e6443d9c4acc3d68fe43597">&#9670;&nbsp;</a></span>hackrf_si5351c_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_si5351c_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intended for debugging purposes only!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">register_number</td><td>register number to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value to write in the specified register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="gad7622cee345a7963a6445943f1b82215" name="gad7622cee345a7963a6445943f1b82215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7622cee345a7963a6445943f1b82215">&#9670;&nbsp;</a></span>hackrf_spiflash_clear_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_spiflash_clear_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >See the datasheet for details of the status registers.</p>
<p >Requires USB API version 0x0103 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga01e1e571ac6928f4c1d32cf8cc817231" name="ga01e1e571ac6928f4c1d32cf8cc817231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e1e571ac6928f4c1d32cf8cc817231">&#9670;&nbsp;</a></span>hackrf_spiflash_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_spiflash_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should be followed by writing a new image, or the HackRF will be soft-bricked (still rescuable in DFU mode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to ersase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga6f53bdd987e128c344f883fea211da98" name="ga6f53bdd987e128c344f883fea211da98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f53bdd987e128c344f883fea211da98">&#9670;&nbsp;</a></span>hackrf_spiflash_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_spiflash_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should only be used for firmware verification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to read from </td></tr>
    <tr><td class="paramname">address</td><td>address to read from. Firmware should start at 0 </td></tr>
    <tr><td class="paramname">length</td><td>length of data to read. Must be at most 256. </td></tr>
    <tr><td class="paramname">data</td><td>pointer to buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga91d4d66e7b47b069fa8db06b7ec46679" name="ga91d4d66e7b47b069fa8db06b7ec46679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91d4d66e7b47b069fa8db06b7ec46679">&#9670;&nbsp;</a></span>hackrf_spiflash_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_spiflash_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >See the datasheet for details of the status registers. The two registers are read in order.</p>
<p >Requires USB API version 0x0103 or above! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>char[2] array of the status registers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
<a id="ga0ee2de669983c9f8d19a52ccb973d3d9" name="ga0ee2de669983c9f8d19a52ccb973d3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee2de669983c9f8d19a52ccb973d3d9">&#9670;&nbsp;</a></span>hackrf_spiflash_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hackrf_spiflash_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device.html#ga90ad9cde4dfa282829aba292b24976b4">hackrf_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should only be used for firmware updating. Can brick the device, but it's still rescuable in DFU mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to write on </td></tr>
    <tr><td class="paramname">address</td><td>address to write to. Should start at 0 </td></tr>
    <tr><td class="paramname">length</td><td>length of data to write. Must be at most 256. </td></tr>
    <tr><td class="paramname">data</td><td>data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__library.html#gga04e277a386c61820f8c522cf54ccdd4ca8291c65694b20c4f5854d017f89b1e99">HACKRF_SUCCESS</a> on success or <a class="el" href="group__library.html#ga04e277a386c61820f8c522cf54ccdd4c">hackrf_error</a> variant </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
